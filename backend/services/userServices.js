const google = require('googleapis').google;
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const appleSignin = require('apple-signin-auth');
const { sendDiscordMessage } = require('./discordWebookService');
const getModels = require('./getModelService');
const { get } = require('../schemas/badgeGrant');

const login = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
);


const register = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI_REGISTER
);

const loginwww = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI_WWW
);


const registerwww = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI_REGISTER_WWW
);



async function registerUser({ username, email, password, req }) {
    const { User } = getModels(req, 'User');
    const existingUsername = await User.findOne({ username });
    const existingEmail = await User.findOne({ email });

    if (existingUsername || existingEmail) {
        const message = existingUsername && existingEmail ? 'Email and username are taken'
            : existingEmail ? 'Email is taken'
                : 'Username is taken';
        throw new Error(message);
    }

    const hashedPassword = await bcrypt.hash(password, 10); // Example hashing
    const user = new User({
        username,
        email: email.toLowerCase(),
        password: hashedPassword
    });
    await user.save();

    return { user };
}

async function loginUser({ email, password, req }) {
    const { User } = getModels(req, 'User');
    //check if it is an email or username
    let user;
    if (!email.includes('@')) {
        user = await User.findOne({ username: email.toLowerCase() })
            .select('-googleId -appleId -refreshToken') // Add fields to exclude
            .lean()
            .populate('clubAssociations'); 
    } else {
        user = await User.findOne({ email: email.toLowerCase() })
            .select('-googleId -appleId -refreshToken') // Add fields to exclude
            .lean()
            .populate('clubAssociations'); 
    }
    if (!user) {
        throw new Error('User not found');
    }

    const passwordMatch = await bcrypt.compare(password, user.password);
    if (!passwordMatch) {
        throw new Error('Invalid credentials');
    }
    delete user.password;
    return { user };
}
function getRedirectUri(url) {
    if (!url) {
        throw new Error('Redirect URI is required');
    }
    
    // Handle iOS native OAuth - reverse client ID format
    // Format: com.googleusercontent.apps.{client-id}:/
    // This is automatically generated by Google for iOS OAuth clients
    const iosReverseClientIdPattern = /^com\.googleusercontent\.apps\.[\w-]+:\/?$/;
    if (iosReverseClientIdPattern.test(url)) {
        console.log(`Google OAuth: iOS native redirect URI detected: ${url}`);
        // Return as-is - Google OAuth validates this automatically for iOS clients
        // No need to register in Google Cloud Console (it's automatic for iOS clients)
        return url;
    }
    
    // Handle Android/custom scheme redirect URIs
    // Format: meridian://auth/google
    // These must be registered in Google Cloud Console as authorized redirect URIs
    if (url.startsWith('meridian://')) {
        console.log(`Google OAuth: Android/custom scheme redirect URI detected: ${url}`);
        const allowedAndroidUris = [
            'meridian://auth/google'
        ];
        
        if (allowedAndroidUris.includes(url)) {
            return url;
        } else {
            throw new Error(`Invalid Android redirect URI: ${url}. Allowed: ${allowedAndroidUris.join(', ')}`);
        }
    }
    
    // Handle Expo proxy redirect URIs (for web application clients)
    // Format: https://auth.expo.io/@project-id/slug
    // These must be registered in Google Cloud Console as authorized redirect URIs
    if (url.startsWith('https://auth.expo.io/@')) {
        console.log(`Google OAuth: Expo proxy redirect URI detected: ${url}`);
        // Validate Expo proxy format: https://auth.expo.io/@project-id/slug
        const expoProxyPattern = /^https:\/\/auth\.expo\.io\/@[\w-]+\/[\w-]+$/;
        if (expoProxyPattern.test(url)) {
            return url;
        } else {
            throw new Error(`Invalid Expo proxy redirect URI format: ${url}`);
        }
    }

    // Handle web redirect URIs
    try {
        const urlObj = new URL(url);
        const hostname = urlObj.hostname;
        const path = urlObj.pathname;

        // Determine the base path for redirect (either login or register)
        const basePath = path.includes('register') ? '/register' : '/login';
        const development = process.env.NODE_ENV === 'development';
        const uri = development ? `http://${hostname}:3000${basePath}` : `https://${hostname}${basePath}`;

        const allowedOrigins = [
            'http://localhost:3000/login',
            'http://localhost:3000/register',
            'https://meridian.study/login',
            'https://meridian.study/register',
            'https://www.meridian.study/login',
            'https://www.meridian.study/register',
            'https://rpi.meridian.study/login',
            'https://rpi.meridian.study/register',
            'https://berkeley.meridian.study/login',
            'https://berkeley.meridian.study/register'
        ];

        if(!allowedOrigins.includes(uri)) {
            throw new Error(`Invalid redirect URI ${uri}`);
        }

        // Return the redirect URI dynamically constructed
        return uri;
    } catch (error) {
        // If URL parsing fails, it might be a malformed URL
        throw new Error(`Invalid redirect URI format: ${url}`);
    }
}

async function authenticateWithGoogleIdToken(idToken, url, req) {
    const { User } = getModels(req, 'User');

    // Verify the ID token using Google's OAuth2Client
    // ID tokens are used by native SDKs (iOS/Android) and don't require PKCE or client secrets
    const {OAuth2Client} = require('google-auth-library');
    const client = new OAuth2Client();
    
    try {
        // Verify the ID token
        // The audience should include all possible client IDs that could have issued this token
        const ticket = await client.verifyIdToken({
            idToken: idToken,
            audience: [
                process.env.GOOGLE_CLIENT_ID, // Primary client ID (iOS client)
                process.env.GOOGLE_WEB_CLIENT_ID,
                process.env.GOOGLE_IOS_CLIENT_ID,
                process.env.GOOGLE_ANDROID_CLIENT_ID,
            ].filter(Boolean), // Remove undefined values
        });
    
        const payload = ticket.getPayload();
        console.log('Google ID token verified. User info:', {
            sub: payload.sub,
            email: payload.email,
            name: payload.name,
        });

        // Find or create user by Google ID
        let user = await User.findOne({ googleId: payload.sub })
            .select('-password -googleId -refreshToken')
            .lean()
            .populate('clubAssociations');

        if (!user) {
            // Check if email already exists (user might have registered with email/password)
            user = await User.findOne({ email: payload.email });
            if (user) {
                // Link Google account to existing user
                user.googleId = payload.sub;
                await User.findByIdAndUpdate(user._id, { googleId: payload.sub });
                user = await User.findById(user._id)
                    .select('-password -googleId -refreshToken')
                    .lean()
                    .populate('clubAssociations');
            } else {
                // Create new user
                const randomUsername = await generateUniqueUsername(payload.email, req);
                user = new User({
                    googleId: payload.sub,
                    email: payload.email,
                    name: payload.name,
                    username: randomUsername,
                    picture: payload.picture
                });
                await user.save();
                sendDiscordMessage(`New user registered`, `user ${user.username} registered via Google ID token`, "newUser");
                
                // Fetch the user again with populated fields
                user = await User.findById(user._id)
                    .select('-password -googleId -refreshToken')
                    .lean()
                    .populate('clubAssociations');
            }
        }

        return { user };
    } catch (error) {
        console.error('Google ID token verification failed:', error);
        throw new Error(`Invalid Google ID token: ${error.message}`);
    }
}

async function authenticateWithGoogle(code, isRegister = false, url, req, codeVerifier = null) {
    const { User } = getModels(req, 'User');

    // Get the redirect URI (handles both web and mobile)
    const redirectUri = getRedirectUri(url);
    
    console.log(`Google OAuth: Using redirect URI: ${redirectUri} (from: ${url})`);
    console.log(`Google OAuth: Code verifier present: ${codeVerifier ? 'Yes' : 'No'}`);

    // Check if this is an iOS native client (reverse client ID format)
    // iOS native clients don't use client secrets - they use PKCE only
    const isIosNative = /^com\.googleusercontent\.apps\.[\w-]+:\/?$/.test(redirectUri);
    
    // For iOS native clients, don't use client secret (they use PKCE only)
    // For web/Android clients, use client secret
    const clientSecret = isIosNative ? undefined : process.env.GOOGLE_CLIENT_SECRET;
    
    console.log(`Google OAuth: Client type: ${isIosNative ? 'iOS Native (PKCE only)' : 'Web/Android (with secret)'}`);
    
    // Create OAuth2 client with the redirect URI
    // iOS native clients: no secret (PKCE only)
    // Web/Android clients: use secret
    const client = new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID,
        clientSecret,
        redirectUri
    );

    try {
        // For PKCE flow, include code verifier in token exchange
        // iOS native clients MUST use PKCE and MUST NOT send client secret
        let tokens;
        if (codeVerifier) {
            console.log('Using PKCE flow with code verifier');
            // For iOS native clients, ensure we don't send client secret
            if (isIosNative) {
                // iOS native: PKCE only, no client secret
                // The OAuth2 client was created without secret, so this should work
                tokens = (await client.getToken({ code, codeVerifier })).tokens;
            } else {
                // Web/Android: PKCE with client secret
                tokens = (await client.getToken({ code, codeVerifier })).tokens;
            }
        } else {
            console.log('Using authorization code flow without PKCE');
            // Non-PKCE flows require client secret (web clients only)
            if (isIosNative) {
                throw new Error('iOS native clients require PKCE (code verifier)');
            }
            tokens = (await client.getToken(code)).tokens;
        }
        client.setCredentials(tokens);

        const oauth2 = google.oauth2({
            auth: client,
            version: 'v2'
        });

        const userInfo = await oauth2.userinfo.get();
        console.log('Google user info:', userInfo.data);
        
        let user = await User.findOne({ googleId: userInfo.data.id })
            .select('-password -googleId -refreshToken') // Add fields to exclude
            .lean()
            .populate('clubAssociations');

        if (!user) {
            //check if email already exists
            user = await User.findOne({ email: userInfo.data.email });
            if (user) {
                throw new Error('Email already exists');
            }

            const randomUsername = await generateUniqueUsername(userInfo.data.email, req);

            user = new User({
                googleId: userInfo.data.id,
                email: userInfo.data.email,
                name: userInfo.data.name,
                username: randomUsername, //replace this with a random username generated
                picture: userInfo.data.picture
            });
            await user.save();
            sendDiscordMessage(`New user registered`, `user ${user.username} registered`, "newUser");
            
            // Fetch the user again with populated fields
            user = await User.findById(user._id)
                .select('-password -googleId -refreshToken')
                .lean()
                .populate('clubAssociations');
        }

        return { user };
    } catch (error) {
        // Enhanced error logging for OAuth token exchange
        if (error.message && error.message.includes('redirect_uri_mismatch')) {
            console.error('Google OAuth redirect URI mismatch. Expected:', redirectUri);
            throw new Error(`OAuth redirect URI mismatch. Please ensure '${redirectUri}' is registered in Google Cloud Console.`);
        }
        throw error;
    }
}

async function generateUniqueUsername(email, req) {
    const { User } = getModels(req, 'User');
    let username =  email.split('@')[0].replace(/[^a-zA-Z0-9]/g, '');
    let isUnique = false;

    do {
        const existingUser = await User.findOne({ username });
        if (!existingUser) {
            isUnique = true;
        } else {
            username += crypto.randomBytes(1).toString('hex');
        }
    } while (!isUnique);


    return username;
}

async function authenticateWithApple(idToken, user, req) {
    const { User } = getModels(req, 'User');

    try {
        // Verify the Apple ID token
        // For web: uses Service ID (com.meridian.auth)
        // For mobile iOS: uses Bundle Identifier (com.meridian.mobile)
        // Accept both to support both web and mobile clients
        const serviceId = 'com.meridian.auth'; // Apple Service ID (web)
        const bundleId = 'com.meridian.mobile'; // Bundle Identifier (iOS mobile)

        // Verify and decode the ID token
        // apple-signin-auth automatically fetches Apple's public keys from JWKS endpoint
        // Try service ID first (web), then bundle ID (mobile)
        const tokenParts = idToken.split('.');
        if (tokenParts.length !== 3) {
            throw new Error('Malformed Apple ID token');
        }
        
        const payload = JSON.parse(
            Buffer.from(tokenParts[1], 'base64').toString('utf8')
        );
        
        const aud = payload.aud;
        
        // Allowed Apple client identifiers
        const SERVICE_ID = 'com.meridian.auth';     // Web
        const BUNDLE_ID  = 'com.meridian.mobile';   // iOS
        
        if (![SERVICE_ID, BUNDLE_ID].includes(aud)) {
            throw new Error(`Unexpected Apple token audience: ${aud}`);
        }
        
        // Verify token using the correct audience
        const decodedToken = await appleSignin.verifyIdToken(idToken, {
            audience: aud, // or clientID: aud (depends on lib version)
            ignoreExpiration: false,
        });
        
        // Optional but recommended hardening
        if (decodedToken.iss !== 'https://appleid.apple.com') {
            throw new Error('Invalid Apple token issuer');
        }

        console.log('Apple user info:', decodedToken);

        // Extract user information
        // Note: Apple only sends email/name on first sign-in. Subsequent sign-ins may not include email.
        const appleId = decodedToken.sub; // Apple user ID
        const email = decodedToken.email || (user && user.email) || null;
        const name = (user && user.name) ? `${user.name.firstName || ''} ${user.name.lastName || ''}`.trim() : null;

        // Find existing user by Apple ID
        let existingUser = await User.findOne({ appleId })
            .select('-password -googleId -appleId -refreshToken')
            .lean()
            .populate('clubAssociations');

        if (existingUser) {
            return { user: existingUser };
        }

        // If no user found by Apple ID, check by email (if provided)
        if (email) {
            existingUser = await User.findOne({ email: email.toLowerCase() });
            if (existingUser) {
                // Link Apple ID to existing account
                // existingUser.appleId = appleId;
                // if (name && !existingUser.name) {
                //     existingUser.name = name;
                // }
                // await existingUser.save();
                
                // // Fetch the user again with populated fields
                // const userDoc = await User.findById(existingUser._id)
                //     .select('-password -googleId -appleId -refreshToken')
                //     .lean()
                //     .populate('clubAssociations');
                
                // return { user: userDoc };
                // throw new Error('Email already exists'); 
                throw new Error('Email already exists'); 
            }
        }

        // Create new user
        if (!email) {
            throw new Error('Email is required for new user registration. Please ensure email scope is requested.');
        }

        const randomUsername = await generateUniqueUsername(email, req);

        const newUser = new User({
            appleId: appleId,
            email: email.toLowerCase(),
            name: name || null,
            username: randomUsername,
            picture: null // Apple doesn't provide profile pictures
        });

        await newUser.save();
        sendDiscordMessage(`New user registered`, `user ${newUser.username} registered via Apple Sign In`, "newUser");

        // Fetch the user again with populated fields
        const userDoc = await User.findById(newUser._id)
            .select('-password -googleId -appleId -refreshToken')
            .lean()
            .populate('clubAssociations');

        return { user: userDoc };
    } catch (error) {
        console.error('Apple Sign In error:', error);
        if (error.message && error.message.includes('TokenExpiredError')) {
            throw new Error('Apple ID token has expired. Please sign in again.');
        }
        if (error.message && error.message.includes('JsonWebTokenError')) {
            throw new Error('Invalid Apple ID token.');
        }
        throw error;
    }
}

module.exports  = { registerUser, loginUser, authenticateWithGoogle, authenticateWithApple, authenticateWithGoogleIdToken };